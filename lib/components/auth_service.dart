import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:sign_in_with_apple/sign_in_with_apple.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'dart:convert';
import 'dart:math';
import 'package:crypto/crypto.dart';

class AuthService {
  final FirebaseAuth _firebaseAuth = FirebaseAuth.instance;


  Stream<User?> authStatesChange() => _firebaseAuth.authStateChanges();

  // ‚úÖ Get User Email
  String getUserEmail() => _firebaseAuth.currentUser?.email ?? 'User';

  // ‚úÖ Fetch House ID Efficiently
  Future<String?> getHouseID(String uid) async {
    final firestore = FirebaseFirestore.instance;
    final SharedPreferences prefs = await SharedPreferences.getInstance();

    print("üì° Fetching houseID for user: $uid from 'houses' collection...");

    // üî• Step 1: Check if the user exists in any house in 'houses' collection
    QuerySnapshot querySnapshot = await firestore
        .collection('houses')
        .where('members', arrayContains: uid) // ‚úÖ Finds where the user is a member
        .limit(1) // Only get the first match
        .get();

    if (querySnapshot.docs.isNotEmpty) {
      String houseID = querySnapshot.docs.first.id; // ‚úÖ Get the house document ID
      print("‚úÖ Found houseID in 'houses' collection: $houseID");

      // ‚úÖ Store houseID in SharedPreferences for faster access
      await prefs.setString('houseID', houseID);
      return houseID;
    }

    // üî• Step 2: If Firestore has no house, remove old SharedPreferences data
    print("‚ùå No house found for user. Clearing SharedPreferences...");
    await prefs.remove('houseID');
    return null;
  }



  String generateNonce([int length = 32]) {
    final random = Random.secure();
    final bytes = List<int>.generate(length, (_) => random.nextInt(256));
    return base64Url.encode(bytes);
  }

  String sha256ofString(String input) {
    final bytes = utf8.encode(input);
    final digest = sha256.convert(bytes);
    return digest.toString();
  }
  Future<void> _updateUserFirestore(UserCredential userCredential, String fullName, String signInMethod) async {
    final user = userCredential.user;
    if (user == null) return;

    final userDoc = FirebaseFirestore.instance.collection('users').doc(user.uid);
    final userSnapshot = await userDoc.get();

    // ‚úÖ Preserve existing user data while updating Firestore
    Map<String, dynamic> userData = {
      'email': user.email ?? "No Email",
      'uid': user.uid,
      'fullName': fullName,
      'signInMethod': signInMethod,
    };

    if (userSnapshot.exists) {
      await userDoc.update(userData);
    } else {
      await userDoc.set(userData);
    }

    print("‚úÖ User data updated in Firestore!");
  }

  Future<String?> _fetchUserFullName(String? uid) async {
    if (uid == null) return null;

    final userDoc = await FirebaseFirestore.instance.collection('users').doc(uid).get();

    if (userDoc.exists && userDoc.data()?['fullName'] != null) {
      print("‚úÖ Found existing full name in Firestore: ${userDoc['fullName']}");
      return userDoc['fullName'];
    }

    print("‚ö†Ô∏è No existing full name found in Firestore.");
    return null; // If no name is found, return null
  }

  Future<UserCredential?> loginWithApple(BuildContext context) async {
    try {
      // ‚úÖ Step 1: Trigger Apple Sign-In
      print("üîÑ Starting Apple Sign-In process...");
      final rawNonce = generateNonce();
      final hashedNonce = sha256ofString(rawNonce);

      if (FirebaseAuth.instance.currentUser != null) {
        print("‚ö†Ô∏è A user is already signed in: ${FirebaseAuth.instance.currentUser!.uid}");
        print("üîÑ Signing out current user before proceeding...");
        await FirebaseAuth.instance.signOut(); // üî• Ensure a fresh sign-in
      }

      final appleCredential = await SignInWithApple.getAppleIDCredential(
        scopes: [AppleIDAuthorizationScopes.email,
          AppleIDAuthorizationScopes.fullName],
        webAuthenticationOptions: WebAuthenticationOptions(
          redirectUri: Uri.parse('https://lock-7a5c7.firebaseapp.com/__/auth/handler'),
          clientId: 'com.anandkamma.lock',
          // Forces fresh login
        ),
        nonce: hashedNonce,
        state: generateNonce(),
      );
      print("‚úÖ Apple Sign-In Successful: ${appleCredential}");
      print("üîç Identity Token: ${appleCredential.identityToken}");
      print("üîç Authorization Code: ${appleCredential.authorizationCode}");
      print("üîç Raw Nonce: $rawNonce");
      print("üîç Hashed Nonce: $hashedNonce");



      if (appleCredential.identityToken == null) {
        print("‚ùå Error: Apple Sign-In did not return an identityToken.");
        return null;
      }

      // ‚úÖ Step 2: Create OAuth credential using the Apple token
      final oAuthCredential = OAuthProvider('apple.com').credential(
        idToken: appleCredential.identityToken,
        accessToken: appleCredential.authorizationCode,
        rawNonce: rawNonce,
      );


      // ‚úÖ Step 3: Sign in with Firebase
      print("üîÑ Signing in with Firebase...");
      UserCredential userCredential = await FirebaseAuth.instance.signInWithCredential(oAuthCredential);
      print("‚úÖ Firebase Sign-In Successful! User: ${userCredential.user?.uid}");

      String? fullName = await _fetchUserFullName(userCredential.user?.uid);

      // ‚úÖ Step 4: Handle missing full name (if Apple doesn‚Äôt provide it)
      if (fullName == null || fullName.isEmpty) {
        // ‚úÖ If no name exists in Firestore, check if Apple provided one
        fullName = appleCredential.givenName != null
            ? "${appleCredential.givenName} ${appleCredential.familyName}".trim()
            : null;

        // ‚úÖ If Apple didn‚Äôt provide a name, ask the user
        if (fullName == null || fullName.isEmpty) {
          print("‚ö†Ô∏è No name found in Firestore. Asking user...");
          fullName = await _askForUserName(context);
        }

        // ‚úÖ Save the name in Firestore
        await _updateUserFirestore(userCredential, fullName, "Apple");
      }
      return userCredential; // üî• Ensure UserCredential is returned

    } catch (e) {

      print("‚ùå Error during Apple Sign-In: $e");

      if (e.toString().contains('user-mismatch')) {
        print("‚ö†Ô∏è Detected user mismatch error. Signing out and retrying...");
        await FirebaseAuth.instance.signOut();

        try {
          print("üîÑ Retrying Apple Sign-In...");
          final rawNonce = generateNonce();
          final hashedNonce = sha256ofString(rawNonce);

          final appleCredential = await SignInWithApple.getAppleIDCredential(
            scopes: [
              AppleIDAuthorizationScopes.email,
              AppleIDAuthorizationScopes.fullName,
            ],
            webAuthenticationOptions: WebAuthenticationOptions(
              redirectUri: Uri.parse('https://YOUR_FIREBASE_PROJECT_ID.firebaseapp.com/__/auth/handler'),
              clientId: 'com.anandkamma.lock',
            ),
            nonce: hashedNonce,
            state: generateNonce(),
          );

          if (appleCredential.identityToken == null) {
            print("‚ùå Error: Apple Sign-In did not return an identityToken.");
            return null;
          }

          final oAuthCredential = OAuthProvider('apple.com').credential(
            idToken: appleCredential.identityToken,
            rawNonce: rawNonce,
          );

          print("üîÑ Signing in with Firebase after retry...");
          UserCredential userCredential = await FirebaseAuth.instance.signInWithCredential(oAuthCredential);
          print("‚úÖ Firebase Sign-In Successful after retry! User: ${userCredential.user?.uid}");

          // ‚úÖ Handle name input if Apple does not provide it
          String? fullName = appleCredential.givenName != null
              ? "${appleCredential.givenName} ${appleCredential.familyName}".trim()
              : null;

          if (fullName == null || fullName.isEmpty) {
            print("‚ö†Ô∏è Apple did not provide a full name. Asking user...");
            fullName = await _askForUserName(context);
          }

          // ‚úÖ Update Firestore with user data
          await _updateUserFirestore(userCredential, fullName, "Apple");

          return userCredential; // üî• Ensure UserCredential is returned after retry

        } catch (retryError) {
          print("‚ùå Error during retry: $retryError");
          return null;
        }
      }

      return null;

    }
  }

  Future<UserCredential?> _signInWithCredential(OAuthCredential credential, {String signInMethod = ''}) async {
    try {
      UserCredential userCredential = await _firebaseAuth.signInWithCredential(credential);
      User user = userCredential.user!;

      // ‚úÖ Fetch existing user data from Firestore
      DocumentSnapshot userDoc = await FirebaseFirestore.instance.collection('users').doc(user.uid).get();
      String? fullName = user.displayName ?? (userDoc.exists ? userDoc['fullName'] ?? 'Unknown User' : 'Unknown User');

      // ‚úÖ Preserve houseID if it exists
      String? existingHouseID;
      Map<String, dynamic>? userData = userDoc.data() as Map<String, dynamic>?; // Explicitly cast
      if (userDoc.exists && userData != null && userData.containsKey('houseID')) {
        existingHouseID = userDoc['houseID'];
      } else {
        existingHouseID = null; // Prevents error if houseID is missing
      }
      // ‚úÖ Update Firestore
      await FirebaseFirestore.instance.collection('users').doc(user.uid).set({
        'email': user.email ?? "No Email",
        'uid': user.uid,
        'fullName': fullName,
        'signInMethod': signInMethod,
        if (existingHouseID != null) 'houseID': existingHouseID, // Preserve houseID
      }, SetOptions(merge: true));

      // ‚úÖ Fetch & store House ID if missing
      await getHouseID(user.uid);

      return userCredential;
    } catch (e) {
      print("‚ùå Error during Sign-In: $e");
      return null;
    }
  }


  // ‚úÖ Google Login (Uses `_signInWithCredential`)
  Future<UserCredential?> loginWithGoogle(BuildContext context) async {
    try {
      await GoogleSignIn().signOut();
      await FirebaseAuth.instance.signOut();
      final googleUser = await GoogleSignIn().signIn();
      if (googleUser == null) {
        print("User cancelled Google Sign-In.");
        return null;
      }

      final GoogleSignInAuthentication googleAuth = await googleUser.authentication;
      final OAuthCredential cred = GoogleAuthProvider.credential(
          idToken: googleAuth.idToken, accessToken: googleAuth.accessToken);

      // ‚úÖ Step 3: Authenticate with Firebase
      UserCredential? userCredential = await _signInWithCredential(cred, signInMethod: 'Google');
      if (userCredential == null) {
        print("‚ùå Google Sign-In Failed!");
        return null;
      }
      print("‚úÖ Google Sign-In Successful: ${userCredential.user?.uid}");


      await Future.delayed(Duration(milliseconds: 500)); // Ensure Firestore sync

      return userCredential;
    } catch (e) {
      print("‚ùå Error during Google Sign-In: $e");
      return null;
    }
  }

  // ‚úÖ Apple Login (Uses `_signInWithCredential`)

  // ‚úÖ Logout
  Future<void> signout() async {
    await _firebaseAuth.signOut();
  }

  // ‚úÖ Ask for User Name if missing
  Future<String> _askForUserName(BuildContext context) async {
    TextEditingController nameController = TextEditingController();

    return await showDialog<String>(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: Color(0xFFcbc7bc), // üîπ Matches background color
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(20), // üîπ Rounded corners
          side: BorderSide(
            color: Color(0xFF38463e), // üîπ Outer border color
            width: 7, // üîπ Outer border thickness
          ),
        ),
        title: Text(
          "Enter Your Name",
          style: TextStyle(
            color: Color(0xFF38463e), // üîπ Matches text color
            fontSize: 22,
            fontWeight: FontWeight.bold,
          ),
        ),
        content: TextField(
          controller: nameController,
          style: TextStyle(color: Color(0xFF38463e)), // üîπ Text color inside field
          decoration: InputDecoration(
            hintText: "Full Name",
            hintStyle: TextStyle(color: Color(0xFF38463e).withOpacity(0.6)), // üîπ Subtle hint text
            filled: true,
            fillColor: Color(0xFFcbc7bc), // üîπ Matches background
            border: OutlineInputBorder(
              borderSide: BorderSide(color: Color(0xFF38463e), width: 2), // üîπ Border color
              borderRadius: BorderRadius.circular(12), // üîπ Rounded text field border
            ),
            focusedBorder: OutlineInputBorder(
              borderSide: BorderSide(color: Color(0xFF38463e), width: 2.5), // üîπ Focus effect
              borderRadius: BorderRadius.circular(12),
            ),
          ),
        ),
        actions: [
          TextButton(
            onPressed: () {
              String enteredName = nameController.text.trim();
              if (enteredName.isNotEmpty) {
                Navigator.pop(context, enteredName);
              }
            },
            style: TextButton.styleFrom(
              foregroundColor: Color(0xFFcbc7bc), // üîπ Text color
              backgroundColor: Color(0xFF38463e), // üîπ Button background
              padding: EdgeInsets.symmetric(horizontal: 20, vertical: 10),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(12), // üîπ Rounded button
              ),
            ),
            child: Text(
              "Submit",
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
          ),
        ],
      ),
    ) ?? "User"; // Default fallback
  }

}
